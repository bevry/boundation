// builtin
import * as pathUtil from 'node:path'

// external
import { first, add, has, intersect } from '@bevry/list'
import { isAccessible } from '@bevry/fs-accessible'
import write from '@bevry/fs-write'
import { fetchAllCompatibleESVersionsForNodeVersions } from '@bevry/nodejs-ecmascript-compatibility'
import { filterNodeVersions } from '@bevry/nodejs-versions'

// local
import { status } from './log.js'
import {
	toLowerCase,
	strip,
	addExtension,
	fixTsc,
	useStrict,
	exportOrExports,
	importOrRequire,
	cojoin,
	set,
	unjoin,
} from './util.js'
import { newPackageBinEntry } from './package.js'
import {
	allTypescriptEcmascriptVersions,
	languageNames,
	defaultBrowsersEcmascriptTarget,
	defaultCoffeeEcmascriptTarget,
} from './data.js'
import { spawn, exec, unlinkIfContains } from './fs.js'
import state from './state.js'

/**
 * Write a loader file for module imports with optional autoloader and TypeScript support
 * @param {object} root0 - Configuration object
 * @param {string} [root0.entry] - Entry point name
 * @param {boolean} [root0.autoloader] - Whether to include autoloader functionality
 * @param {boolean} [root0.exportDefault] - Whether to export as default
 * @param {string} [root0.typesPath] - Path to TypeScript type definitions
 * @param {string} [root0.targetEntry] - Target entry point name
 * @param {string} [root0.targetPath] - Target file path
 * @returns {Promise<void>} Promise that resolves when loader is written
 */
async function writeLoader({
	entry = 'index',
	autoloader = false,
	exportDefault = false,
	typesPath = '',
	targetEntry = '',
	targetPath = '',
}) {
	const bin = entry.startsWith('bin')
	const mjs = entry.endsWith('.mjs')
	const cjs = !mjs
	const lines = [
		bin && '#!/usr/bin/env node',
		cjs && "'use strict'",
		'// auto-generated by boundation, do not update manually',
	]
	if (autoloader) {
		if (mjs) {
			// https://github.com/bevry/editions/issues/83
			throw new Error('autoloader does not yet support mjs')
		}
		lines.push(`/** @type {typeof import("${cojoin('.', typesPath)}") } */`)
		if (targetEntry) {
			lines.push(
				`module.exports = require('editions').requirePackage(__dirname, require, '${targetEntry}')`,
			)
		} else {
			lines.push(
				`module.exports = require('editions').requirePackage(__dirname, require)`,
			)
		}
	} else {
		if (mjs) lines.push(`export * from './${targetPath}'`)
		if (exportDefault) {
			lines.push(
				`import d from './${targetPath}'`,
				// cjs exports {default} instead of default
				'export default ' + (cjs ? 'd.default || d' : 'd'),
			)
		}
		if (cjs) lines.push(`module.exports = require('./${targetPath}')`)
	}
	await write(entry, lines.filter((i) => i).join('\n'))
}

/**
 * Write root entry file with edition handling and autoloader support
 * @param {object} root0 - Configuration object
 * @param {string} [root0.entry] - Entry point name
 * @param {boolean} [root0.autoloader] - Whether to include autoloader functionality
 * @param {boolean} [root0.always] - Whether to always load editions
 * @param {boolean} [root0.exportDefault] - Whether to export as default
 * @param {object} root0.sourceEdition - Source edition configuration
 * @param {object} root0.typesEdition - Types edition configuration
 * @param {object} root0.nodeEditionRequire - Node require edition configuration
 * @param {object} root0.nodeEditionImport - Node import edition configuration
 * @returns {Promise<void>} Promise that resolves when root entry is written
 */
async function writeRootEntry({
	entry = 'index',
	autoloader = false,
	always = false,
	exportDefault = false, // eslint-disable-line
	sourceEdition,
	typesEdition,
	nodeEditionRequire,
	nodeEditionImport,
}) {
	// prepare
	const typesPath = typesEdition
		? typesEdition[entry + 'Path']
		: sourceEdition[entry + 'Path']
	// resolve
	let resolved
	if (nodeEditionRequire) {
		if (autoloader || always) {
			const entryWithExtension = entry + '.cjs'
			await writeLoader({
				entry: entryWithExtension,
				autoloader,
				typesPath,
				targetEntry: nodeEditionRequire[entry],
				targetPath: nodeEditionRequire[entry + 'Path'],
			})
			resolved = entryWithExtension
		} else {
			resolved = nodeEditionRequire[entry + 'Path']
		}
	} else if (nodeEditionImport) {
		if (autoloader) {
			throw new Error('autoloader does not yet support only mjs')
		} else if (always) {
			const entryWithExtension = entry + '.mjs'
			await writeLoader({
				entry: entryWithExtension,
				autoloader,
				typesPath,
				targetEntry: nodeEditionImport[entry],
				targetPath: nodeEditionImport[entry + 'Path'],
			})
			resolved = entryWithExtension
		} else {
			// package.json:exports.import dismisses the need for a .mjs loader file
			resolved = nodeEditionImport[entry + 'Path']
		}
	}
	// always resolve, as node doesn't support extensionless entries inside package.json
	return resolved
}

// Helpers
class Edition {
	constructor(opts) {
		Object.defineProperty(this, 'description', {
			enumerable: true,
			get() {
				// ensure description exists
				const edition = this
				const browserSupport = edition.engines && edition.engines.browsers
				const nodeSupport = edition.engines && edition.engines.node
				const ecmascriptSupport = edition.targets && edition.targets.ecmascript
				const description = [
					languageNames[state.answers.language] || state.answers.language,
					edition.directory === state.answers.sourceDirectory
						? 'source code'
						: 'compiled',
				]
				if (ecmascriptSupport && typeof ecmascriptSupport === 'string') {
					// what the typescript compiler targets
					description.push(`against ${ecmascriptSupport}`)
				}
				if (browserSupport) {
					description.push(`for web browsers`)
					if (
						typeof browserSupport === 'string' &&
						browserSupport !== 'defaults'
					) {
						description.push(`[${browserSupport}]`)
					}
				}
				if (nodeSupport) {
					description.push(browserSupport ? 'and' : 'for', `Node.js`)
					if (typeof nodeSupport === 'string') {
						// typescript compiler will be true, as typescript doesn't compile to specific node versions
						description.push(`${nodeSupport}`)
					}
				}
				if (has(edition.tags, 'types')) {
					description.push('Types')
				}
				if (has(edition.tags, 'require')) {
					description.push('with Require for modules')
				} else if (has(edition.tags, 'import')) {
					description.push('with Import for modules')
				}
				return description.join(' ')
			},
		})

		Object.defineProperty(this, 'targets', {
			enumerable: false,
			writable: true,
		})

		Object.defineProperty(this, 'dependencies', {
			enumerable: false,
			writable: true,
		})

		Object.defineProperty(this, 'devDependencies', {
			enumerable: false,
			writable: true,
		})

		Object.defineProperty(this, 'compiler', {
			enumerable: false,
			writable: true,
		})

		Object.defineProperty(this, 'scripts', {
			enumerable: false,
			writable: true,
		})

		Object.defineProperty(this, 'compiler', {
			enumerable: false,
			writable: true,
		})

		Object.defineProperty(this, 'babel', { enumerable: false, writable: true })

		Object.defineProperty(this, 'active', { enumerable: false, writable: true })

		Object.defineProperty(this, 'entry', {
			enumerable: false,
			get() {
				const engines = []
				for (const [name, supported] of Object.entries(this.engines)) {
					if (supported) engines.push(name)
				}
				const entry =
					engines.length !== 1 ? this.index : this[engines[0]] || this.index
				return entry
			},
		})

		Object.defineProperty(this, 'index', { enumerable: false, writable: true })

		Object.defineProperty(this, 'node', { enumerable: false, writable: true })

		Object.defineProperty(this, 'browser', {
			enumerable: false,
			writable: true,
		})

		Object.defineProperty(this, 'test', { enumerable: false, writable: true })

		Object.defineProperty(this, 'bin', { enumerable: false, writable: true })

		Object.defineProperty(this, 'indexPath', {
			enumerable: false,
			get() {
				return this.index && pathUtil.join(this.directory || '.', this.index)
			},
		})

		// entry path is an indexPath that actually has engines
		Object.defineProperty(this, 'entryPath', {
			enumerable: false,
			get() {
				return this.entry && pathUtil.join(this.directory || '.', this.entry)
			},
		})

		Object.defineProperty(this, 'nodePath', {
			enumerable: false,
			get() {
				return this.node && pathUtil.join(this.directory || '.', this.node)
			},
		})

		Object.defineProperty(this, 'browserPath', {
			enumerable: false,
			get() {
				return (
					this.browser && pathUtil.join(this.directory || '.', this.browser)
				)
			},
		})

		Object.defineProperty(this, 'testPath', {
			enumerable: false,
			get() {
				return this.test && pathUtil.join(this.directory || '.', this.test)
			},
		})

		Object.defineProperty(this, 'binPath', {
			enumerable: false,
			get() {
				return this.bin && pathUtil.join(this.directory || '.', this.bin)
			},
		})

		Object.defineProperty(this, 'compileCommand', {
			enumerable: false,
			writable: true,
		})

		opts.tags = new Set(opts.tags || [])
		opts.dependencies = new Set(opts.dependencies || [])
		opts.devDependencies = new Set(opts.devDependencies || [])

		Object.assign(this, { scripts: {}, active: true }, opts)
	}
}

/**
 * Generate editions configuration and files for the project
 * @param {object} state - Application state containing packageData and answers
 * @returns {Promise<void>} Promise that resolves when editions are generated
 */
export async function generateEditions(state) {
	const { answers, packageData } = state

	// log
	status('updating editions...')

	// source edition
	if (answers.website) {
		delete packageData.main
		state.editions = [
			new Edition({
				directory: '.',
				tags: [
					'source',
					'website',
					...answers.languages,
					answers.sourceModule ? 'import' : 'require',
				],
			}),
		]
	} else {
		const editions = new Map()

		// Generate source edition based on language
		if (answers.language === 'javascript') {
			const edition = new Edition({
				directory: answers.sourceDirectory,
				index: addExtension(answers.indexEntry, `js`),
				node: addExtension(answers.nodeEntry, `js`),
				browser: addExtension(answers.browserEntry, `js`),
				test: addExtension(answers.testEntry, `js`),
				bin: addExtension(answers.binEntry, `js`),
				tags: [
					'source',
					'javascript',
					answers.ecmascriptVersion,
					answers.sourceModule ? 'import' : 'require',
				],
				engines: {
					node: true,
					browsers: answers.browsersTargeted && !answers.compilerBrowser,
				},
			})

			if (answers.flowtype) {
				add(edition.tags, 'flow type comments')
			}

			editions.set('source', edition)
		} else if (answers.language === 'typescript') {
			editions.set(
				'source',
				new Edition({
					directory: answers.sourceDirectory,
					index: addExtension(answers.indexEntry, `ts`),
					node: addExtension(answers.nodeEntry, `ts`),
					browser: addExtension(answers.browserEntry, `ts`),
					test: addExtension(answers.testEntry, `ts`),
					bin: addExtension(answers.binEntry, `js`),
					tags: ['source', 'typescript', answers.ecmascriptVersion, 'import'],
					engines: false,
				}),
			)
		} else if (answers.language === 'coffeescript') {
			editions.set(
				'source',
				new Edition({
					directory: answers.sourceDirectory,
					index: addExtension(answers.indexEntry, `coffee`),
					node: addExtension(answers.nodeEntry, `coffee`),
					browser: addExtension(answers.browserEntry, `coffee`),
					test: addExtension(answers.testEntry, `coffee`),
					bin: addExtension(answers.binEntry, `coffee`),
					tags: ['source', 'coffeescript', 'require'],
					engines: false,
				}),
			)
		} else if (answers.language === 'json') {
			editions.set(
				'source',
				new Edition({
					directory: answers.sourceDirectory,
					index: addExtension(answers.indexEntry, `json`),
					node: addExtension(answers.nodeEntry, `json`),
					browser: addExtension(answers.browserEntry, `json`),
					test: addExtension(answers.testEntry, `js`),
					bin: addExtension(answers.binEntry, `js`),
					tags: ['source', 'json', 'es5'],
					engines: {
						node: true,
						browsers: answers.browsersTargeted && !answers.compilerBrowser,
					},
				}),
			)
		} else {
			throw new Error('language should have been defined, but it was missing')
		}

		// add browser edition
		if (answers.compilerBrowser) {
			editions.set(
				'browser',
				new Edition({
					compiler: answers.compilerBrowser,
					// for legacy b/c reasons this is not "edition-browser"
					directory: 'edition-browsers',
					index: addExtension(answers.browserEntry, `js`),
					browser: addExtension(answers.browserEntry, `js`),
					test: addExtension(answers.testEntry, `js`),
					bin: addExtension(answers.binEntry, `js`),
					tags: [
						'compiled',
						'javascript',
						answers.sourceModule ? 'import' : 'require',
					],
					targets: {
						browsers: answers.browsersTargeted, // babel compiler uses this
						ecmascript: defaultBrowsersEcmascriptTarget, // typescript compiler uses this
					},
					engines: {
						node: false,
						browsers: answers.browsersTargeted,
					},
				}),
			)
		}

		// add coffeescript edition
		if (answers.compilerNode === 'coffeescript') {
			const directory = `edition-${defaultCoffeeEcmascriptTarget}`
			editions.set(
				'coffeescript',
				new Edition({
					compiler: 'coffeescript',
					directory,
					index: addExtension(answers.indexEntry, `js`),
					node: addExtension(answers.nodeEntry, `js`),
					browser: addExtension(answers.browserEntry, `js`),
					test: addExtension(answers.testEntry, `js`),
					bin: addExtension(answers.binEntry, `js`),
					tags: [
						'compiled',
						'javascript',
						defaultCoffeeEcmascriptTarget,
						'require',
					],
					engines: {
						node: true,
						browsers: answers.browsersTargeted,
					},
				}),
			)
		}
		// add edition for each babel/typescript target
		else if (
			answers.compilerNode === 'babel' ||
			answers.compilerNode === 'typescript'
		) {
			for (const targetModule of answers.targetModules) {
				/* eslint no-undefined:0 */
				const nodeVersionsTargets = filterNodeVersions(
					answers.nodeVersionsTargeted,
					{
						esm: targetModule === 'import',
						range:
							targetModule === 'import'
								? answers.nodeVersionsTargetedImportRange
								: targetModule === 'require'
									? answers.nodeVersionsTargetedRequireRange
									: undefined,
					},
				)
					.slice()
					.reverse() // reverse modifies the actual array, hence need for slice
				if (answers.compilerNode === 'babel') {
					for (const nodeVersionTarget of nodeVersionsTargets) {
						// fetch ecmascript version which is essential for accurate: compilation, prettier/eslint configuration, and ode v6 which is es5
						const ecmascriptVersionTarget = toLowerCase(
							await fetchAllCompatibleESVersionsForNodeVersions([
								nodeVersionTarget,
							]),
						).reverse()[0]
						const directory =
							`edition-node-${nodeVersionTarget}` +
							(targetModule === 'import' ? '-esm' : '')
						editions.set(
							directory,
							new Edition({
								compiler: 'babel',
								directory,
								index: addExtension(answers.indexEntry, `js`),
								node: addExtension(answers.nodeEntry, `js`),
								browser: addExtension(answers.browserEntry, `js`),
								test: addExtension(answers.testEntry, `js`),
								bin: addExtension(answers.binEntry, `js`),
								tags: [
									'compiled',
									'javascript',
									ecmascriptVersionTarget,
									targetModule,
								],
								targets: {
									node: nodeVersionTarget,
									ecmascript: ecmascriptVersionTarget,
								},
								engines: {
									node: true,
									browsers: false,
								},
							}),
						)
					}
				} else if (answers.compilerNode === 'typescript') {
					const ecmascriptVersionTargetToEdition = new Map()
					for (const nodeVersionTarget of nodeVersionsTargets) {
						// fetch the latest ecmascript version for the node.js version target that typescript supports
						const ecmascriptVersionTarget =
							first(
								intersect(
									allTypescriptEcmascriptVersions,
									toLowerCase(
										await fetchAllCompatibleESVersionsForNodeVersions([
											nodeVersionTarget,
										]),
									),
								),
							) || ''
						// check that typescript supported it
						if (!ecmascriptVersionTarget) continue
						// prepare
						const directory =
							`edition-${ecmascriptVersionTarget}` +
							(targetModule === 'import' ? '-esm' : '')
						// check that we haven't already generated an edition for this ecmascript version target target
						const existingEdition = ecmascriptVersionTargetToEdition.get(
							ecmascriptVersionTarget,
						)
						if (existingEdition) {
							existingEdition.targets.node += ` || ${nodeVersionTarget}`
							// the existingEdition is happening via ecmascriptVersionTarget, so there is no point modifying: existingEdition.targets.ecmascript
							console.info(
								'merge',
								existingEdition.directory,
								existingEdition.targets.node,
								existingEdition.targets.ecmascript,
							)
						} else {
							const edition = new Edition({
								compiler: 'typescript',
								directory,
								index: addExtension(answers.indexEntry, `js`),
								node: addExtension(answers.nodeEntry, `js`),
								browser: addExtension(answers.browserEntry, `js`),
								test: addExtension(answers.testEntry, `js`),
								bin: addExtension(answers.binEntry, `js`),
								tags: [
									'compiled',
									'javascript',
									ecmascriptVersionTarget,
									targetModule,
								],
								targets: {
									node: nodeVersionTarget,
									ecmascript: ecmascriptVersionTarget,
								},
								engines: {
									node: true,
									browsers: false,
								},
							})
							editions.set(directory, edition)
							ecmascriptVersionTargetToEdition.set(
								ecmascriptVersionTarget,
								edition,
							)
							console.info(
								'added',
								directory,
								nodeVersionTarget,
								ecmascriptVersionTarget,
							)
						}
					}
				} else {
					throw new Error(`invalid target for the compiler`)
				}
			}
		}

		// add types
		if (answers.language === 'typescript') {
			editions.set(
				'types',
				new Edition({
					compiler: 'types',
					directory: 'edition-types',
					index: addExtension(answers.indexEntry, `d.ts`),
					node: addExtension(answers.nodeEntry, `d.ts`),
					browser: addExtension(answers.browserEntry, `d.ts`),
					test: addExtension(answers.testEntry, `d.ts`),
					bin: addExtension(answers.binEntry, `d.ts`),
					tags: ['compiled', 'types', 'import'],
					engines: false,
				}),
			)
		} else {
			// define the possible locations
			// do note that they must exist throughout boundation, which if it is a compiled dir, is sporadic
			const sourceEdition = editions.get('source')
			const typePaths = [
				// e.g. index.d.ts
				pathUtil.join(answers.indexEntry + '.d.ts'),
				// e.g. source/index.d.ts
				sourceEdition &&
					pathUtil.join(sourceEdition.directory, answers.indexEntry + '.d.ts'),
			].filter((i) => i)
			// fetch their existing status and convert back into the original location
			const typePathsExisting = await Promise.all(
				typePaths.map((i) => isAccessible(i).then((e) => e && i)),
			)
			// find the first location that exists
			const typePath = typePathsExisting.find((i) => i)
			// and if exists, add our types edition
			if (typePath) {
				editions.set(
					'types',
					new Edition({
						directory: '.',
						index: typePath,
						tags: ['types', answers.sourceModule ? 'import' : 'require'],
						engines: false,
					}),
				)
			}
		}

		// update state
		state.editions = Array.from(editions.values())
	}

	// log
	console.info(
		'editions:',
		state.editions.map((edition) => edition.directory).join(', '),
	)
	status('...updated editions')
}

/**
 * Update edition-specific fields and compilation scripts
 * @param {object} state - Application state containing answers and editions
 * @returns {void}
 */
export function updateEditionFields(state) {
	const { answers, editions } = state

	// autogenerate various fields
	editions.forEach(function (edition) {
		const compileScriptName = `our:compile:${edition.directory}`

		// add compilation details
		if (edition.compiler === 'coffeescript') {
			edition.scripts[compileScriptName] =
				`coffee -bco ./${edition.directory} ./${answers.sourceDirectory}`
		} else if (edition.compiler === 'types') {
			edition.scripts[compileScriptName] = [
				'tsc',
				'--emitDeclarationOnly',
				'--declaration',
				'--declarationMap',
				`--declarationDir ./${edition.directory}`,
				`--project ${answers.tsconfig}`,
				...fixTsc(edition.directory, answers.sourceDirectory),
			]
				.filter((part) => part)
				.join(' ')
		} else if (edition.compiler === 'typescript') {
			edition.scripts[compileScriptName] = [
				'tsc',
				has(edition.tags, 'require') ? '--module commonjs' : '--module esnext',
				`--target ${edition.targets.ecmascript}`,
				`--outDir ./${edition.directory}`,
				`--project ${answers.tsconfig}`,
				...fixTsc(edition.directory, answers.sourceDirectory),
				// doesn't work: '|| true', // fixes failures where types may be temporarily missing
			]
				.filter((part) => part)
				.join(' ')
		} else if (edition.compiler === 'babel') {
			if (answers.language === 'coffeescript') {
				// add coffee compile script
				edition.scripts[compileScriptName] = [
					`env BABEL_ENV=${edition.directory}`,
					'coffee -bcto',
					`./${edition.directory}/`,
					`./${answers.sourceDirectory}`,
				]
					.filter((part) => part)
					.join(' ')
			} else {
				// add babel compile script
				edition.scripts[compileScriptName] = [
					`env BABEL_ENV=${edition.directory}`,
					'babel',
					answers.language === 'typescript' ? '--extensions ".ts,.tsx"' : '',
					`--out-dir ./${edition.directory}`,
					`./${answers.sourceDirectory}`,
				]
					.filter((part) => part)
					.join(' ')
			}

			// populate babel
			edition.babel = {
				sourceType: answers.sourceModule ? 'module' : 'script',
				presets: [
					[
						// https://babeljs.io/docs/babel-preset-env
						// https://babeljs.io/docs/options#targets
						// https://babeljs.io/docs/options#targetsbrowsers
						// https://babeljs.io/docs/options#targetsnode
						// https://babeljs.io/docs/options#targetsdeno
						'@babel/preset-env',
						{
							targets: strip(edition.targets, 'ecmascript'),
							modules: has(edition.tags, 'import')
								? answers.sourceModule
									? false
									: 'auto'
								: 'commonjs',
						},
					],
				],
				plugins: ['@babel/plugin-transform-object-rest-spread'],
			}

			add(
				edition.devDependencies,
				'@babel/cli',
				'@babel/core',
				'@babel/plugin-transform-object-rest-spread',
				'@babel/preset-env',
			)

			if (answers.language === 'typescript') {
				add(edition.babel.presets, '@babel/preset-typescript')
				add(
					edition.babel.plugins,
					'@babel/plugin-proposal-class-properties',
					'@babel/plugin-proposal-optional-chaining',
				)
				add(
					edition.devDependencies,
					'@babel/core',
					'@babel/plugin-proposal-class-properties',
					'@babel/plugin-proposal-optional-chaining',
					'@babel/plugin-transform-object-rest-spread',
					'@babel/preset-typescript',
				)
			}
		}

		// add the package.json type information to the edition
		if (edition.engines.node && edition.scripts[compileScriptName]) {
			const packageType = has(edition.tags, 'require') ? 'commonjs' : 'module'
			edition.scripts[compileScriptName] +=
				` && printf '%s' '{"type": "${packageType}"}' > ${edition.directory}/package.json`
		}

		// note the compiler command
		edition.compileCommand = [answers.packageManager, 'run', compileScriptName]
	})
}

/**
 * Update package.json entry points and exports based on edition configurations
 * @param {object} state - Application state containing edition data and packageData
 * @returns {void}
 */
export function updateEditionEntries(state) {
	const {
		typesEdition,
		nodeEditionRequire,
		nodeEditionImport,
		browserEdition,
		packageData,
	} = state

	// reset
	delete packageData.node
	delete packageData.mjs
	delete packageData.cjs

	// https://nodejs.org/api/esm.html#esm_conditional_exports
	// https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#package-json-exports-imports-and-self-referencing
	// https://nodejs.org/api/packages.html#packages_exports
	// https://nodejs.org/api/packages.html#package-entry-points
	// https://nodejs.org/api/packages.html#subpath-exports
	// https://nodejs.org/api/packages.html#conditional-exports
	packageData.exports = {}

	// types
	// https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html
	const typesIndexPath = cojoin('.', typesEdition && typesEdition.indexPath)
	if (typesIndexPath) {
		packageData.types = typesEdition.indexPath // don't prefix the ./
	}

	// node exports
	const autoloaderPath = cojoin(
		'.',
		state.useEditionsAutoloader && packageData.main,
	)
	const nodeImportPath = cojoin(
		'.',
		nodeEditionImport && nodeEditionImport.indexPath,
	)
	const nodeRequirePath = cojoin(
		'.',
		nodeEditionRequire && nodeEditionRequire.indexPath,
	)
	if (nodeImportPath || autoloaderPath || nodeRequirePath) {
		const nodeExports = {}
		set(nodeExports, 'types', typesIndexPath || null)
		set(nodeExports, 'import', nodeImportPath || null)
		set(nodeExports, 'default', autoloaderPath || null) // default before require, as require should be direct, whereas the autoloader is indirect, as intended
		set(nodeExports, 'require', nodeRequirePath || null)
		set(packageData.exports, 'node', nodeExports)
	}

	// browser exports
	const browserPath = cojoin('.', browserEdition && browserEdition.indexPath)
	const browserImportPath =
		has(browserEdition && browserEdition.tags, 'import') && browserPath
	const browserRequirePath =
		has(browserEdition && browserEdition.tags, 'require') && browserPath
	if (browserImportPath || browserRequirePath) {
		const browserExports = {}
		set(browserExports, 'types', typesIndexPath || null)
		set(browserExports, 'import', browserImportPath || null)
		set(browserExports, 'require', browserRequirePath || null)
		set(packageData.exports, 'browser', browserExports)
	}
	set(packageData, 'browser', unjoin('.', browserPath) || null)
	set(packageData, 'module', unjoin('.', browserImportPath) || null)

	// // default exports
	// const activePath = cojoin('.', activeEdition && activeEdition.indexPath)
	// const activeImportPath =
	// 	has(activeEdition && activeEdition.tags, 'import') && activePath
	// const activeRequirePath =
	// 	has(activeEdition && activeEdition.tags, 'require') && activePath
	// if (activeImportPath || activeRequirePath) {
	// 	const defaultExports = {}
	// 	set(defaultExports, 'types', typesIndexPath || null)
	// 	set(defaultExports, 'import', activeImportPath || null)
	// 	set(defaultExports, 'require', activeRequirePath || null)
	// 	set(packageData.exports, 'default', defaultExports)
	// }
	// ^ this never worked due to activeEdition not resolving due to missing getter, currently activeEdition is resolving to typescript source edition, which isn't what we want, so just ignore it for now.

	// delete the exports if we don't need it
	// this is required for for eslint-config-bevry/adapt.js
	// as if node.js handles exports, it only allows exported paths and that is it
	if (!nodeImportPath) delete packageData.exports
}

/**
 * Scaffold edition files and directories, creating entry points and test files
 * @param {object} state - Application state containing editions, packageData, and answers
 * @returns {Promise<void>} Promise that resolves when editions are scaffolded
 */
export async function scaffoldEditions(state) {
	// fetch
	const {
		typesEdition,
		sourceEdition,
		nodeEdition,
		nodeEditionRequire,
		nodeEditionImport,
		activeEditions,
		packageData,
		answers,
	} = state

	// clean old edition files
	await unlinkIfContains(
		[
			'bin.js',
			'bin.cjs',
			'bin.mjs',
			'index.js',
			'index.cjs',
			'index.mjs',
			'test.js',
			'test.cjs',
			'test.mjs',
		],
		'auto-generated by boundation',
	)

	// export default
	let exportDefault = false
	answers.keywords.delete('export-default')
	if (answers.sourceModule) {
		try {
			await exec(`cat ${sourceEdition.indexPath} | grep 'export default'`)
			exportDefault = true
			answers.keywords.add('export-default')
		} catch {}
	}

	// handle
	if (activeEditions.length) {
		// log
		status('scaffolding edition files...')

		// scaffold edition directories
		await spawn(
			['mkdir', '-p'].concat(
				activeEditions.map((edition) => edition.directory || '.'),
			),
		)

		// move or scaffold edition main path if needed
		if (sourceEdition.indexPath) {
			if ((await isAccessible(sourceEdition.indexPath)) === false) {
				// edition index entry doesn't exist, but it is a docpad plugin
				if (answers.docpadPlugin) {
					await write(
						sourceEdition.indexPath,
						[
							useStrict(answers.sourceModule),
							exportOrExports(
								"class MyPlugin extends require('docpad-baseplugin') {",
								answers.sourceModule,
							),
							"\tget name () { return 'myplugin' }",
							'\tget initialConfig () { return {} }',
							'}',
							'',
						].join('\n'),
					)
				}
				// edition index entry doesn't exist, so create an empty file
				else {
					await write(
						sourceEdition.indexPath,
						[
							useStrict(answers.sourceModule),
							exportOrExports("'@todo'", answers.sourceModule),
							'',
						].join('\n'),
					)
				}
			}
		}

		// move or scaffold edition test path if needed
		if (sourceEdition.testPath) {
			if (answers.docpadPlugin === false) {
				if ((await isAccessible(sourceEdition.testPath)) === false) {
					// edition test entry doesn't exist, so create a basic test file
					if (answers.kava) {
						await write(
							sourceEdition.testPath,
							[
								useStrict(answers.sourceModule),
								importOrRequire(
									'{equal}',
									'assert-helpers',
									answers.sourceModule,
								),
								importOrRequire('kava', 'kava', answers.sourceModule),
								'',
								`kava.suite('${packageData.name}', function (suite, test) {`,
								"\ttest('no tests yet', function () {",
								"\t\tconsole.log('no tests yet')",
								'\t})',
								'})',
								'',
							].join('\n'),
						)
					} else {
						await write(
							sourceEdition.testPath,
							[
								useStrict(answers.sourceModule),
								exportOrExports("'@todo'", answers.sourceModule),
								'',
							].join('\n'),
						)
					}
				}
			}
		}

		// setup paths
		if (nodeEdition) {
			packageData.main = await writeRootEntry({
				entry: 'index',
				autoloader: state.useEditionsAutoloader,
				exportDefault,
				typesEdition,
				sourceEdition,
				nodeEditionRequire,
				nodeEditionImport,
			})

			// bin
			if (answers.binEntry) {
				packageData.bin = newPackageBinEntry(
					packageData,
					await writeRootEntry({
						entry: 'bin',
						always: true,
						autoloader: state.useEditionsAutoloader,
						exportDefault,
						typesEdition,
						sourceEdition,
						nodeEditionRequire,
						nodeEditionImport,
					}),
				)
			} else {
				delete packageData.bin
			}

			// don't bother test with docpad plugins
			// as they hae their own testing solution
			if (answers.docpadPlugin === false) {
				state.test = await writeRootEntry({
					entry: 'test',
					autoloader: state.useEditionsAutoloader,
					exportDefault,
					typesEdition,
					sourceEdition,
					nodeEditionRequire,
					nodeEditionImport,
				})
			}
		}
		// no node edition, so no testing
		else {
			delete packageData.main
			delete packageData.bin
			delete packageData.test
			delete state.test
		}

		// make the type what the source edition is
		// as the compiled editions get their own package.json file
		// this does however require that example files get their appropriate extension
		packageData.type = has(sourceEdition.tags, 'import') ? 'module' : 'commonjs'

		// browser path
		updateEditionEntries(state)

		// log
		status('...scaffolded edition files')
	}
	// no editions
	else {
		// delete type, as no way of determining what it should be
		delete packageData.type

		// go directly to source
		if (answers.indexEntry) {
			packageData.main = answers.indexEntry + '.js'
		}
		updateEditionEntries(state)
		if (answers.testEntry) {
			state.test = answers.testEntry + '.js'
		}
		if (answers.binEntry) {
			packageData.bin = newPackageBinEntry(
				packageData,
				answers.binEntry + '.js',
			)
		} else {
			delete packageData.bin
		}
	}
}
